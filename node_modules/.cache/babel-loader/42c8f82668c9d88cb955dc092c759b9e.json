{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\n\nconst codegen_1 = require(\"./codegen\");\n\nconst code_1 = require(\"./codegen/code\"); // TODO refactor to use Set\n\n\nfunction toHash(arr) {\n  const hash = {};\n\n  for (const item of arr) hash[item] = true;\n\n  return hash;\n}\n\nexports.toHash = toHash;\n\nfunction alwaysValidSchema(it, schema) {\n  if (typeof schema == \"boolean\") return schema;\n  if (Object.keys(schema).length === 0) return true;\n  checkUnknownRules(it, schema);\n  return !schemaHasRules(schema, it.self.RULES.all);\n}\n\nexports.alwaysValidSchema = alwaysValidSchema;\n\nfunction checkUnknownRules(it, schema = it.schema) {\n  const {\n    opts,\n    self\n  } = it;\n  if (!opts.strictSchema) return;\n  if (typeof schema === \"boolean\") return;\n  const rules = self.RULES.keywords;\n\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`);\n  }\n}\n\nexports.checkUnknownRules = checkUnknownRules;\n\nfunction schemaHasRules(schema, rules) {\n  if (typeof schema == \"boolean\") return !schema;\n\n  for (const key in schema) if (rules[key]) return true;\n\n  return false;\n}\n\nexports.schemaHasRules = schemaHasRules;\n\nfunction schemaHasRulesButRef(schema, RULES) {\n  if (typeof schema == \"boolean\") return !schema;\n\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true;\n\n  return false;\n}\n\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\n\nfunction schemaRefOrVal({\n  topSchemaRef,\n  schemaPath\n}, schema, keyword, $data) {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema;\n    if (typeof schema == \"string\") return codegen_1._`${schema}`;\n  }\n\n  return codegen_1._`${topSchemaRef}${schemaPath}${codegen_1.getProperty(keyword)}`;\n}\n\nexports.schemaRefOrVal = schemaRefOrVal;\n\nfunction unescapeFragment(str) {\n  return unescapeJsonPointer(decodeURIComponent(str));\n}\n\nexports.unescapeFragment = unescapeFragment;\n\nfunction escapeFragment(str) {\n  return encodeURIComponent(escapeJsonPointer(str));\n}\n\nexports.escapeFragment = escapeFragment;\n\nfunction escapeJsonPointer(str) {\n  if (typeof str == \"number\") return `${str}`;\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n\nexports.escapeJsonPointer = escapeJsonPointer;\n\nfunction unescapeJsonPointer(str) {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n\nexports.unescapeJsonPointer = unescapeJsonPointer;\n\nfunction eachItem(xs, f) {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x);\n  } else {\n    f(xs);\n  }\n}\n\nexports.eachItem = eachItem;\n\nfunction makeMergeEvaluated({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName\n}) {\n  return (gen, from, to, toName) => {\n    const res = to === undefined ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);\n    return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n  };\n}\n\nexports.mergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) => gen.if(codegen_1._`${to} !== true && ${from} !== undefined`, () => {\n      gen.if(codegen_1._`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, codegen_1._`${to} || {}`).code(codegen_1._`Object.assign(${to}, ${from})`));\n    }),\n    mergeToName: (gen, from, to) => gen.if(codegen_1._`${to} !== true`, () => {\n      if (from === true) {\n        gen.assign(to, true);\n      } else {\n        gen.assign(to, codegen_1._`${to} || {}`);\n        setEvaluated(gen, to, from);\n      }\n    }),\n    mergeValues: (from, to) => from === true ? true : { ...from,\n      ...to\n    },\n    resultToName: evaluatedPropsToName\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) => gen.if(codegen_1._`${to} !== true && ${from} !== undefined`, () => gen.assign(to, codegen_1._`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n    mergeToName: (gen, from, to) => gen.if(codegen_1._`${to} !== true`, () => gen.assign(to, from === true ? true : codegen_1._`${to} > ${from} ? ${to} : ${from}`)),\n    mergeValues: (from, to) => from === true ? true : Math.max(from, to),\n    resultToName: (gen, items) => gen.var(\"items\", items)\n  })\n};\n\nfunction evaluatedPropsToName(gen, ps) {\n  if (ps === true) return gen.var(\"props\", true);\n  const props = gen.var(\"props\", codegen_1._`{}`);\n  if (ps !== undefined) setEvaluated(gen, props, ps);\n  return props;\n}\n\nexports.evaluatedPropsToName = evaluatedPropsToName;\n\nfunction setEvaluated(gen, props, ps) {\n  Object.keys(ps).forEach(p => gen.assign(codegen_1._`${props}${codegen_1.getProperty(p)}`, true));\n}\n\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\n\nfunction useFunc(gen, f) {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))\n  });\n}\n\nexports.useFunc = useFunc;\nvar Type;\n\n(function (Type) {\n  Type[Type[\"Num\"] = 0] = \"Num\";\n  Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type = exports.Type || (exports.Type = {}));\n\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n  // let path\n  if (dataProp instanceof codegen_1.Name) {\n    const isNumber = dataPropType === Type.Num;\n    return jsPropertySyntax ? isNumber ? codegen_1._`\"[\" + ${dataProp} + \"]\"` : codegen_1._`\"['\" + ${dataProp} + \"']\"` : isNumber ? codegen_1._`\"/\" + ${dataProp}` : codegen_1._`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n  }\n\n  return jsPropertySyntax ? codegen_1.getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\n\nexports.getErrorPath = getErrorPath;\n\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n  if (!mode) return;\n  msg = `strict mode: ${msg}`;\n  if (mode === true) throw new Error(msg);\n  it.self.logger.warn(msg);\n}\n\nexports.checkStrictMode = checkStrictMode;","map":null,"metadata":{},"sourceType":"script"}