{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\n\nconst code_1 = require(\"./code\");\n\nclass ValueError extends Error {\n  constructor(name) {\n    super(`CodeGen: \"code\" for ${name} not defined`);\n    this.value = name.value;\n  }\n\n}\n\nvar UsedValueState;\n\n(function (UsedValueState) {\n  UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n  UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));\n\nexports.varKinds = {\n  const: new code_1.Name(\"const\"),\n  let: new code_1.Name(\"let\"),\n  var: new code_1.Name(\"var\")\n};\n\nclass Scope {\n  constructor({\n    prefixes,\n    parent\n  } = {}) {\n    this._names = {};\n    this._prefixes = prefixes;\n    this._parent = parent;\n  }\n\n  toName(nameOrPrefix) {\n    return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n  }\n\n  name(prefix) {\n    return new code_1.Name(this._newName(prefix));\n  }\n\n  _newName(prefix) {\n    const ng = this._names[prefix] || this._nameGroup(prefix);\n\n    return `${prefix}${ng.index++}`;\n  }\n\n  _nameGroup(prefix) {\n    var _a, _b;\n\n    if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n    }\n\n    return this._names[prefix] = {\n      prefix,\n      index: 0\n    };\n  }\n\n}\n\nexports.Scope = Scope;\n\nclass ValueScopeName extends code_1.Name {\n  constructor(prefix, nameStr) {\n    super(nameStr);\n    this.prefix = prefix;\n  }\n\n  setValue(value, {\n    property,\n    itemIndex\n  }) {\n    this.value = value;\n    this.scopePath = code_1._`.${new code_1.Name(property)}[${itemIndex}]`;\n  }\n\n}\n\nexports.ValueScopeName = ValueScopeName;\nconst line = code_1._`\\n`;\n\nclass ValueScope extends Scope {\n  constructor(opts) {\n    super(opts);\n    this._values = {};\n    this._scope = opts.scope;\n    this.opts = { ...opts,\n      _n: opts.lines ? line : code_1.nil\n    };\n  }\n\n  get() {\n    return this._scope;\n  }\n\n  name(prefix) {\n    return new ValueScopeName(prefix, this._newName(prefix));\n  }\n\n  value(nameOrPrefix, value) {\n    var _a;\n\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\");\n    const name = this.toName(nameOrPrefix);\n    const {\n      prefix\n    } = name;\n    const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n    let vs = this._values[prefix];\n\n    if (vs) {\n      const _name = vs.get(valueKey);\n\n      if (_name) return _name;\n    } else {\n      vs = this._values[prefix] = new Map();\n    }\n\n    vs.set(valueKey, name);\n    const s = this._scope[prefix] || (this._scope[prefix] = []);\n    const itemIndex = s.length;\n    s[itemIndex] = value.ref;\n    name.setValue(value, {\n      property: prefix,\n      itemIndex\n    });\n    return name;\n  }\n\n  getValue(prefix, keyOrRef) {\n    const vs = this._values[prefix];\n    if (!vs) return;\n    return vs.get(keyOrRef);\n  }\n\n  scopeRefs(scopeName, values = this._values) {\n    return this._reduceValues(values, name => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`);\n      return code_1._`${scopeName}${name.scopePath}`;\n    });\n  }\n\n  scopeCode(values = this._values, usedValues, getCode) {\n    return this._reduceValues(values, name => {\n      if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`);\n      return name.value.code;\n    }, usedValues, getCode);\n  }\n\n  _reduceValues(values, valueCode, usedValues = {}, getCode) {\n    let code = code_1.nil;\n\n    for (const prefix in values) {\n      const vs = values[prefix];\n      if (!vs) continue;\n      const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();\n      vs.forEach(name => {\n        if (nameSet.has(name)) return;\n        nameSet.set(name, UsedValueState.Started);\n        let c = valueCode(name);\n\n        if (c) {\n          const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n          code = code_1._`${code}${def} ${name} = ${c};${this.opts._n}`;\n        } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {\n          code = code_1._`${code}${c}${this.opts._n}`;\n        } else {\n          throw new ValueError(name);\n        }\n\n        nameSet.set(name, UsedValueState.Completed);\n      });\n    }\n\n    return code;\n  }\n\n}\n\nexports.ValueScope = ValueScope;","map":null,"metadata":{},"sourceType":"script"}