{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst types_1 = require(\"../discriminator/types\");\n\nconst error = {\n  message: ({\n    params: {\n      discrError,\n      tagName\n    }\n  }) => discrError === types_1.DiscrError.Tag ? `tag \"${tagName}\" must be string` : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({\n    params: {\n      discrError,\n      tag,\n      tagName\n    }\n  }) => codegen_1._`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`\n};\nconst def = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      schema,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      oneOf\n    } = parentSchema;\n\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\");\n    }\n\n    const tagName = schema.propertyName;\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\");\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\");\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\");\n    const valid = gen.let(\"valid\", false);\n    const tag = gen.const(\"tag\", codegen_1._`${data}${codegen_1.getProperty(tagName)}`);\n    gen.if(codegen_1._`typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, {\n      discrError: types_1.DiscrError.Tag,\n      tag,\n      tagName\n    }));\n    cxt.ok(valid);\n\n    function validateMapping() {\n      const mapping = getMapping();\n      gen.if(false);\n\n      for (const tagValue in mapping) {\n        gen.elseIf(codegen_1._`${tag} === ${tagValue}`);\n        gen.assign(valid, applyTagSchema(mapping[tagValue]));\n      }\n\n      gen.else();\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Mapping,\n        tag,\n        tagName\n      });\n      gen.endIf();\n    }\n\n    function applyTagSchema(schemaProp) {\n      const _valid = gen.name(\"valid\");\n\n      const schCxt = cxt.subschema({\n        keyword: \"oneOf\",\n        schemaProp\n      }, _valid);\n      cxt.mergeEvaluated(schCxt, codegen_1.Name);\n      return _valid;\n    }\n\n    function getMapping() {\n      var _a;\n\n      const oneOfMapping = {};\n      const topRequired = hasRequired(parentSchema);\n      let tagRequired = true;\n\n      for (let i = 0; i < oneOf.length; i++) {\n        const sch = oneOf[i];\n        const propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n\n        if (typeof propSch != \"object\") {\n          throw new Error(`discriminator: oneOf schemas must have \"properties/${tagName}\"`);\n        }\n\n        tagRequired = tagRequired && (topRequired || hasRequired(sch));\n        addMappings(propSch, i);\n      }\n\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`);\n      return oneOfMapping;\n\n      function hasRequired({\n        required\n      }) {\n        return Array.isArray(required) && required.includes(tagName);\n      }\n\n      function addMappings(sch, i) {\n        if (sch.const) {\n          addMapping(sch.const, i);\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i);\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n        }\n      }\n\n      function addMapping(tagValue, i) {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n        }\n\n        oneOfMapping[tagValue] = i;\n      }\n    }\n  }\n\n};\nexports.default = def;","map":null,"metadata":{},"sourceType":"script"}