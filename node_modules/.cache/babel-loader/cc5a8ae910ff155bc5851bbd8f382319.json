{"ast":null,"code":"\"use strict\";\n/* IMPORT */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeFileSync = exports.writeFile = exports.readFileSync = exports.readFile = void 0;\n\nconst path = require(\"path\");\n\nconst consts_1 = require(\"./consts\");\n\nconst fs_1 = require(\"./utils/fs\");\n\nconst lang_1 = require(\"./utils/lang\");\n\nconst scheduler_1 = require(\"./utils/scheduler\");\n\nconst temp_1 = require(\"./utils/temp\");\n\nfunction readFile(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {\n  var _a;\n\n  if (lang_1.default.isString(options)) return readFile(filePath, {\n    encoding: options\n  });\n  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);\n  return fs_1.default.readFileRetry(timeout)(filePath, options);\n}\n\nexports.readFile = readFile;\n;\n\nfunction readFileSync(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {\n  var _a;\n\n  if (lang_1.default.isString(options)) return readFileSync(filePath, {\n    encoding: options\n  });\n  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);\n  return fs_1.default.readFileSyncRetry(timeout)(filePath, options);\n}\n\nexports.readFileSync = readFileSync;\n;\n\nconst writeFile = (filePath, data, options, callback) => {\n  if (lang_1.default.isFunction(options)) return writeFile(filePath, data, consts_1.DEFAULT_WRITE_OPTIONS, options);\n  const promise = writeFileAsync(filePath, data, options);\n  if (callback) promise.then(callback, callback);\n  return promise;\n};\n\nexports.writeFile = writeFile;\n\nconst writeFileAsync = async (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {\n  var _a;\n\n  if (lang_1.default.isString(options)) return writeFileAsync(filePath, data, {\n    encoding: options\n  });\n  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);\n  let schedulerCustomDisposer = null,\n      schedulerDisposer = null,\n      tempDisposer = null,\n      tempPath = null,\n      fd = null;\n\n  try {\n    if (options.schedule) schedulerCustomDisposer = await options.schedule(filePath);\n    schedulerDisposer = await scheduler_1.default.schedule(filePath);\n    filePath = (await fs_1.default.realpathAttempt(filePath)) || filePath;\n    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));\n    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown),\n          useStatMode = lang_1.default.isUndefined(options.mode);\n\n    if (useStatChown || useStatMode) {\n      const stat = await fs_1.default.statAttempt(filePath);\n\n      if (stat) {\n        options = { ...options\n        };\n        if (useStatChown) options.chown = {\n          uid: stat.uid,\n          gid: stat.gid\n        };\n        if (useStatMode) options.mode = stat.mode;\n      }\n    }\n\n    const parentPath = path.dirname(filePath);\n    await fs_1.default.mkdirAttempt(parentPath, {\n      mode: consts_1.DEFAULT_FOLDER_MODE,\n      recursive: true\n    });\n    fd = await fs_1.default.openRetry(timeout)(tempPath, 'w', options.mode || consts_1.DEFAULT_FILE_MODE);\n    if (options.tmpCreated) options.tmpCreated(tempPath);\n\n    if (lang_1.default.isString(data)) {\n      await fs_1.default.writeRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);\n    } else if (!lang_1.default.isUndefined(data)) {\n      await fs_1.default.writeRetry(timeout)(fd, data, 0, data.length, 0);\n    }\n\n    if (options.fsync !== false) {\n      if (options.fsyncWait !== false) {\n        await fs_1.default.fsyncRetry(timeout)(fd);\n      } else {\n        fs_1.default.fsyncAttempt(fd);\n      }\n    }\n\n    await fs_1.default.closeRetry(timeout)(fd);\n    fd = null;\n    if (options.chown) await fs_1.default.chownAttempt(tempPath, options.chown.uid, options.chown.gid);\n    if (options.mode) await fs_1.default.chmodAttempt(tempPath, options.mode);\n\n    try {\n      await fs_1.default.renameRetry(timeout)(tempPath, filePath);\n    } catch (error) {\n      if (error.code !== 'ENAMETOOLONG') throw error;\n      await fs_1.default.renameRetry(timeout)(tempPath, temp_1.default.truncate(filePath));\n    }\n\n    tempDisposer();\n    tempPath = null;\n  } finally {\n    if (fd) await fs_1.default.closeAttempt(fd);\n    if (tempPath) temp_1.default.purge(tempPath);\n    if (schedulerCustomDisposer) schedulerCustomDisposer();\n    if (schedulerDisposer) schedulerDisposer();\n  }\n};\n\nconst writeFileSync = (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {\n  var _a;\n\n  if (lang_1.default.isString(options)) return writeFileSync(filePath, data, {\n    encoding: options\n  });\n  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);\n  let tempDisposer = null,\n      tempPath = null,\n      fd = null;\n\n  try {\n    filePath = fs_1.default.realpathSyncAttempt(filePath) || filePath;\n    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));\n    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown),\n          useStatMode = lang_1.default.isUndefined(options.mode);\n\n    if (useStatChown || useStatMode) {\n      const stat = fs_1.default.statSyncAttempt(filePath);\n\n      if (stat) {\n        options = { ...options\n        };\n        if (useStatChown) options.chown = {\n          uid: stat.uid,\n          gid: stat.gid\n        };\n        if (useStatMode) options.mode = stat.mode;\n      }\n    }\n\n    const parentPath = path.dirname(filePath);\n    fs_1.default.mkdirSyncAttempt(parentPath, {\n      mode: consts_1.DEFAULT_FOLDER_MODE,\n      recursive: true\n    });\n    fd = fs_1.default.openSyncRetry(timeout)(tempPath, 'w', options.mode || consts_1.DEFAULT_FILE_MODE);\n    if (options.tmpCreated) options.tmpCreated(tempPath);\n\n    if (lang_1.default.isString(data)) {\n      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);\n    } else if (!lang_1.default.isUndefined(data)) {\n      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, data.length, 0);\n    }\n\n    if (options.fsync !== false) {\n      if (options.fsyncWait !== false) {\n        fs_1.default.fsyncSyncRetry(timeout)(fd);\n      } else {\n        fs_1.default.fsyncAttempt(fd);\n      }\n    }\n\n    fs_1.default.closeSyncRetry(timeout)(fd);\n    fd = null;\n    if (options.chown) fs_1.default.chownSyncAttempt(tempPath, options.chown.uid, options.chown.gid);\n    if (options.mode) fs_1.default.chmodSyncAttempt(tempPath, options.mode);\n\n    try {\n      fs_1.default.renameSyncRetry(timeout)(tempPath, filePath);\n    } catch (error) {\n      if (error.code !== 'ENAMETOOLONG') throw error;\n      fs_1.default.renameSyncRetry(timeout)(tempPath, temp_1.default.truncate(filePath));\n    }\n\n    tempDisposer();\n    tempPath = null;\n  } finally {\n    if (fd) fs_1.default.closeSyncAttempt(fd);\n    if (tempPath) temp_1.default.purge(tempPath);\n  }\n};\n\nexports.writeFileSync = writeFileSync;","map":null,"metadata":{},"sourceType":"script"}