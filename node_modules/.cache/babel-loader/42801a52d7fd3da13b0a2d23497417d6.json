{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  }\n\n  privateMap.set(receiver, value);\n  return value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n};\n\nvar _a, _b;\n\nvar _validator, _encryptionKey, _options, _defaultValues;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst util_1 = require(\"util\");\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst crypto = require(\"crypto\");\n\nconst assert = require(\"assert\");\n\nconst events_1 = require(\"events\");\n\nconst dotProp = require(\"dot-prop\");\n\nconst pkgUp = require(\"pkg-up\");\n\nconst envPaths = require(\"env-paths\");\n\nconst atomically = require(\"atomically\");\n\nconst ajv_1 = require(\"ajv\");\n\nconst ajv_formats_1 = require(\"ajv-formats\");\n\nconst debounceFn = require(\"debounce-fn\");\n\nconst semver = require(\"semver\");\n\nconst onetime = require(\"onetime\");\n\nconst encryptionAlgorithm = 'aes-256-cbc';\n\nconst createPlainObject = () => {\n  return Object.create(null);\n};\n\nconst isExist = data => {\n  return data !== undefined && data !== null;\n};\n\nlet parentDir = '';\n\ntry {\n  // Prevent caching of this module so module.parent is always accurate.\n  // Note: This trick won't work with ESM or inside a webworker\n  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n  delete require.cache[__filename];\n  parentDir = path.dirname((_b = (_a = module.parent) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : '.');\n} catch (_c) {}\n\nconst checkValueType = (key, value) => {\n  const nonJsonTypes = new Set(['undefined', 'symbol', 'function']);\n  const type = typeof value;\n\n  if (nonJsonTypes.has(type)) {\n    throw new TypeError(`Setting a value of type \\`${type}\\` for key \\`${key}\\` is not allowed as it's not supported by JSON`);\n  }\n};\n\nconst INTERNAL_KEY = '__internal__';\nconst MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;\n\nclass Conf {\n  constructor(partialOptions = {}) {\n    var _a;\n\n    _validator.set(this, void 0);\n\n    _encryptionKey.set(this, void 0);\n\n    _options.set(this, void 0);\n\n    _defaultValues.set(this, {});\n\n    this._deserialize = value => JSON.parse(value);\n\n    this._serialize = value => JSON.stringify(value, undefined, '\\t');\n\n    const options = {\n      configName: 'config',\n      fileExtension: 'json',\n      projectSuffix: 'nodejs',\n      clearInvalidConfig: false,\n      accessPropertiesByDotNotation: true,\n      ...partialOptions\n    };\n    const getPackageData = onetime(() => {\n      const packagePath = pkgUp.sync({\n        cwd: parentDir\n      }); // Can't use `require` because of Webpack being annoying:\n      // https://github.com/webpack/webpack/issues/196\n\n      const packageData = packagePath && JSON.parse(fs.readFileSync(packagePath, 'utf8'));\n      return packageData !== null && packageData !== void 0 ? packageData : {};\n    });\n\n    if (!options.cwd) {\n      if (!options.projectName) {\n        options.projectName = getPackageData().name;\n      }\n\n      if (!options.projectName) {\n        throw new Error('Project name could not be inferred. Please specify the `projectName` option.');\n      }\n\n      options.cwd = envPaths(options.projectName, {\n        suffix: options.projectSuffix\n      }).config;\n    }\n\n    __classPrivateFieldSet(this, _options, options);\n\n    if (options.schema) {\n      if (typeof options.schema !== 'object') {\n        throw new TypeError('The `schema` option must be an object.');\n      }\n\n      const ajv = new ajv_1.default({\n        allErrors: true,\n        useDefaults: true\n      });\n      ajv_formats_1.default(ajv);\n      const schema = {\n        type: 'object',\n        properties: options.schema\n      };\n\n      __classPrivateFieldSet(this, _validator, ajv.compile(schema));\n\n      for (const [key, value] of Object.entries(options.schema)) {\n        if (value === null || value === void 0 ? void 0 : value.default) {\n          __classPrivateFieldGet(this, _defaultValues)[key] = value.default;\n        }\n      }\n    }\n\n    if (options.defaults) {\n      __classPrivateFieldSet(this, _defaultValues, { ...__classPrivateFieldGet(this, _defaultValues),\n        ...options.defaults\n      });\n    }\n\n    if (options.serialize) {\n      this._serialize = options.serialize;\n    }\n\n    if (options.deserialize) {\n      this._deserialize = options.deserialize;\n    }\n\n    this.events = new events_1.EventEmitter();\n\n    __classPrivateFieldSet(this, _encryptionKey, options.encryptionKey);\n\n    const fileExtension = options.fileExtension ? `.${options.fileExtension}` : '';\n    this.path = path.resolve(options.cwd, `${(_a = options.configName) !== null && _a !== void 0 ? _a : 'config'}${fileExtension}`);\n    const fileStore = this.store;\n    const store = Object.assign(createPlainObject(), options.defaults, fileStore);\n\n    this._validate(store);\n\n    try {\n      assert.deepEqual(fileStore, store);\n    } catch (_b) {\n      this.store = store;\n    }\n\n    if (options.watch) {\n      this._watch();\n    }\n\n    if (options.migrations) {\n      if (!options.projectVersion) {\n        options.projectVersion = getPackageData().version;\n      }\n\n      if (!options.projectVersion) {\n        throw new Error('Project version could not be inferred. Please specify the `projectVersion` option.');\n      }\n\n      this._migrate(options.migrations, options.projectVersion);\n    }\n  }\n\n  get(key, defaultValue) {\n    if (__classPrivateFieldGet(this, _options).accessPropertiesByDotNotation) {\n      return this._get(key, defaultValue);\n    }\n\n    return key in this.store ? this.store[key] : defaultValue;\n  }\n\n  set(key, value) {\n    if (typeof key !== 'string' && typeof key !== 'object') {\n      throw new TypeError(`Expected \\`key\\` to be of type \\`string\\` or \\`object\\`, got ${typeof key}`);\n    }\n\n    if (typeof key !== 'object' && value === undefined) {\n      throw new TypeError('Use `delete()` to clear values');\n    }\n\n    if (this._containsReservedKey(key)) {\n      throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);\n    }\n\n    const {\n      store\n    } = this;\n\n    const set = (key, value) => {\n      checkValueType(key, value);\n\n      if (__classPrivateFieldGet(this, _options).accessPropertiesByDotNotation) {\n        dotProp.set(store, key, value);\n      } else {\n        store[key] = value;\n      }\n    };\n\n    if (typeof key === 'object') {\n      const object = key;\n\n      for (const [key, value] of Object.entries(object)) {\n        set(key, value);\n      }\n    } else {\n      set(key, value);\n    }\n\n    this.store = store;\n  }\n  /**\n  Check if an item exists.\n   @param key - The key of the item to check.\n  */\n\n\n  has(key) {\n    if (__classPrivateFieldGet(this, _options).accessPropertiesByDotNotation) {\n      return dotProp.has(this.store, key);\n    }\n\n    return key in this.store;\n  }\n  /**\n  Reset items to their default values, as defined by the `defaults` or `schema` option.\n   @see `clear()` to reset all items.\n   @param keys - The keys of the items to reset.\n  */\n\n\n  reset(...keys) {\n    for (const key of keys) {\n      if (isExist(__classPrivateFieldGet(this, _defaultValues)[key])) {\n        this.set(key, __classPrivateFieldGet(this, _defaultValues)[key]);\n      }\n    }\n  }\n  /**\n  Delete an item.\n   @param key - The key of the item to delete.\n  */\n\n\n  delete(key) {\n    const {\n      store\n    } = this;\n\n    if (__classPrivateFieldGet(this, _options).accessPropertiesByDotNotation) {\n      dotProp.delete(store, key);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete store[key];\n    }\n\n    this.store = store;\n  }\n  /**\n  Delete all items.\n   This resets known items to their default values, if defined by the `defaults` or `schema` option.\n  */\n\n\n  clear() {\n    this.store = createPlainObject();\n\n    for (const key of Object.keys(__classPrivateFieldGet(this, _defaultValues))) {\n      this.reset(key);\n    }\n  }\n  /**\n  Watches the given `key`, calling `callback` on any changes.\n   @param key - The key wo watch.\n  @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.\n  @returns A function, that when called, will unsubscribe.\n  */\n\n\n  onDidChange(key, callback) {\n    if (typeof key !== 'string') {\n      throw new TypeError(`Expected \\`key\\` to be of type \\`string\\`, got ${typeof key}`);\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError(`Expected \\`callback\\` to be of type \\`function\\`, got ${typeof callback}`);\n    }\n\n    return this._handleChange(() => this.get(key), callback);\n  }\n  /**\n  Watches the whole config object, calling `callback` on any changes.\n   @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.\n  @returns A function, that when called, will unsubscribe.\n  */\n\n\n  onDidAnyChange(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError(`Expected \\`callback\\` to be of type \\`function\\`, got ${typeof callback}`);\n    }\n\n    return this._handleChange(() => this.store, callback);\n  }\n\n  get size() {\n    return Object.keys(this.store).length;\n  }\n\n  get store() {\n    try {\n      const data = fs.readFileSync(this.path, __classPrivateFieldGet(this, _encryptionKey) ? null : 'utf8');\n\n      const dataString = this._encryptData(data);\n\n      const deserializedData = this._deserialize(dataString);\n\n      this._validate(deserializedData);\n\n      return Object.assign(createPlainObject(), deserializedData);\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        this._ensureDirectory();\n\n        return createPlainObject();\n      }\n\n      if (__classPrivateFieldGet(this, _options).clearInvalidConfig && error.name === 'SyntaxError') {\n        return createPlainObject();\n      }\n\n      throw error;\n    }\n  }\n\n  set store(value) {\n    this._ensureDirectory();\n\n    this._validate(value);\n\n    this._write(value);\n\n    this.events.emit('change');\n  }\n\n  *[(_validator = new WeakMap(), _encryptionKey = new WeakMap(), _options = new WeakMap(), _defaultValues = new WeakMap(), Symbol.iterator)]() {\n    for (const [key, value] of Object.entries(this.store)) {\n      yield [key, value];\n    }\n  }\n\n  _encryptData(data) {\n    if (!__classPrivateFieldGet(this, _encryptionKey)) {\n      return data.toString();\n    }\n\n    try {\n      // Check if an initialization vector has been used to encrypt the data\n      if (__classPrivateFieldGet(this, _encryptionKey)) {\n        try {\n          if (data.slice(16, 17).toString() === ':') {\n            const initializationVector = data.slice(0, 16);\n            const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _encryptionKey), initializationVector.toString(), 10000, 32, 'sha512');\n            const decipher = crypto.createDecipheriv(encryptionAlgorithm, password, initializationVector);\n            data = Buffer.concat([decipher.update(Buffer.from(data.slice(17))), decipher.final()]).toString('utf8');\n          } else {\n            const decipher = crypto.createDecipher(encryptionAlgorithm, __classPrivateFieldGet(this, _encryptionKey));\n            data = Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]).toString('utf8');\n          }\n        } catch (_a) {}\n      }\n    } catch (_b) {}\n\n    return data.toString();\n  }\n\n  _handleChange(getter, callback) {\n    let currentValue = getter();\n\n    const onChange = () => {\n      const oldValue = currentValue;\n      const newValue = getter();\n\n      if (util_1.isDeepStrictEqual(newValue, oldValue)) {\n        return;\n      }\n\n      currentValue = newValue;\n      callback.call(this, newValue, oldValue);\n    };\n\n    this.events.on('change', onChange);\n    return () => this.events.removeListener('change', onChange);\n  }\n\n  _validate(data) {\n    if (!__classPrivateFieldGet(this, _validator)) {\n      return;\n    }\n\n    const valid = __classPrivateFieldGet(this, _validator).call(this, data);\n\n    if (valid || !__classPrivateFieldGet(this, _validator).errors) {\n      return;\n    }\n\n    const errors = __classPrivateFieldGet(this, _validator).errors.map(({\n      instancePath,\n      message = ''\n    }) => `\\`${instancePath.slice(1)}\\` ${message}`);\n\n    throw new Error('Config schema violation: ' + errors.join('; '));\n  }\n\n  _ensureDirectory() {\n    // Ensure the directory exists as it could have been deleted in the meantime.\n    fs.mkdirSync(path.dirname(this.path), {\n      recursive: true\n    });\n  }\n\n  _write(value) {\n    let data = this._serialize(value);\n\n    if (__classPrivateFieldGet(this, _encryptionKey)) {\n      const initializationVector = crypto.randomBytes(16);\n      const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _encryptionKey), initializationVector.toString(), 10000, 32, 'sha512');\n      const cipher = crypto.createCipheriv(encryptionAlgorithm, password, initializationVector);\n      data = Buffer.concat([initializationVector, Buffer.from(':'), cipher.update(Buffer.from(data)), cipher.final()]);\n    } // Temporary workaround for Conf being packaged in a Ubuntu Snap app.\n    // See https://github.com/sindresorhus/conf/pull/82\n\n\n    if (process.env.SNAP) {\n      fs.writeFileSync(this.path, data);\n    } else {\n      try {\n        atomically.writeFileSync(this.path, data);\n      } catch (error) {\n        // Fix for https://github.com/sindresorhus/electron-store/issues/106\n        // Sometimes on Windows, we will get an EXDEV error when atomic writing\n        // (even though to the same directory), so we fall back to non atomic write\n        if (error.code === 'EXDEV') {\n          fs.writeFileSync(this.path, data);\n          return;\n        }\n\n        throw error;\n      }\n    }\n  }\n\n  _watch() {\n    this._ensureDirectory();\n\n    if (!fs.existsSync(this.path)) {\n      this._write(createPlainObject());\n    }\n\n    fs.watch(this.path, {\n      persistent: false\n    }, debounceFn(() => {\n      // On Linux and Windows, writing to the config file emits a `rename` event, so we skip checking the event type.\n      this.events.emit('change');\n    }, {\n      wait: 100\n    }));\n  }\n\n  _migrate(migrations, versionToMigrate) {\n    let previousMigratedVersion = this._get(MIGRATION_KEY, '0.0.0');\n\n    const newerVersions = Object.keys(migrations).filter(candidateVersion => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));\n    let storeBackup = { ...this.store\n    };\n\n    for (const version of newerVersions) {\n      try {\n        const migration = migrations[version];\n        migration(this);\n\n        this._set(MIGRATION_KEY, version);\n\n        previousMigratedVersion = version;\n        storeBackup = { ...this.store\n        };\n      } catch (error) {\n        this.store = storeBackup;\n        throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error}`);\n      }\n    }\n\n    if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver.eq(previousMigratedVersion, versionToMigrate)) {\n      this._set(MIGRATION_KEY, versionToMigrate);\n    }\n  }\n\n  _containsReservedKey(key) {\n    if (typeof key === 'object') {\n      const firsKey = Object.keys(key)[0];\n\n      if (firsKey === INTERNAL_KEY) {\n        return true;\n      }\n    }\n\n    if (typeof key !== 'string') {\n      return false;\n    }\n\n    if (__classPrivateFieldGet(this, _options).accessPropertiesByDotNotation) {\n      if (key.startsWith(`${INTERNAL_KEY}.`)) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return false;\n  }\n\n  _isVersionInRangeFormat(version) {\n    return semver.clean(version) === null;\n  }\n\n  _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {\n    if (this._isVersionInRangeFormat(candidateVersion)) {\n      if (previousMigratedVersion !== '0.0.0' && semver.satisfies(previousMigratedVersion, candidateVersion)) {\n        return false;\n      }\n\n      return semver.satisfies(versionToMigrate, candidateVersion);\n    }\n\n    if (semver.lte(candidateVersion, previousMigratedVersion)) {\n      return false;\n    }\n\n    if (semver.gt(candidateVersion, versionToMigrate)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  _get(key, defaultValue) {\n    return dotProp.get(this.store, key, defaultValue);\n  }\n\n  _set(key, value) {\n    const {\n      store\n    } = this;\n    dotProp.set(store, key, value);\n    this.store = store;\n  }\n\n}\n\nexports.default = Conf; // For CommonJS default export support\n\nmodule.exports = Conf;\nmodule.exports.default = Conf;","map":null,"metadata":{},"sourceType":"script"}