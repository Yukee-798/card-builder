{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: ({\n    params: {\n      min,\n      max\n    }\n  }) => max === undefined ? codegen_1.str`must contain at least ${min} valid item(s)` : codegen_1.str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({\n    params: {\n      min,\n      max\n    }\n  }) => max === undefined ? codegen_1._`{minContains: ${min}}` : codegen_1._`{minContains: ${min}, maxContains: ${max}}`\n};\nconst def = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      it\n    } = cxt;\n    let min;\n    let max;\n    const {\n      minContains,\n      maxContains\n    } = parentSchema;\n\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains;\n      max = maxContains;\n    } else {\n      min = 1;\n    }\n\n    const len = gen.const(\"len\", codegen_1._`${data}.length`);\n    cxt.setParams({\n      min,\n      max\n    });\n\n    if (max === undefined && min === 0) {\n      util_1.checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n      return;\n    }\n\n    if (max !== undefined && min > max) {\n      util_1.checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`);\n      cxt.fail();\n      return;\n    }\n\n    if (util_1.alwaysValidSchema(it, schema)) {\n      let cond = codegen_1._`${len} >= ${min}`;\n      if (max !== undefined) cond = codegen_1._`${cond} && ${len} <= ${max}`;\n      cxt.pass(cond);\n      return;\n    }\n\n    it.items = true;\n    const valid = gen.name(\"valid\");\n\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()));\n    } else {\n      gen.let(valid, false);\n      const schValid = gen.name(\"_valid\");\n      const count = gen.let(\"count\", 0);\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n    }\n\n    cxt.result(valid, () => cxt.reset());\n\n    function validateItems(_valid, block) {\n      gen.forRange(\"i\", 0, len, i => {\n        cxt.subschema({\n          keyword: \"contains\",\n          dataProp: i,\n          dataPropType: util_1.Type.Num,\n          compositeRule: true\n        }, _valid);\n        block();\n      });\n    }\n\n    function checkLimits(count) {\n      gen.code(codegen_1._`${count}++`);\n\n      if (max === undefined) {\n        gen.if(codegen_1._`${count} >= ${min}`, () => gen.assign(valid, true).break());\n      } else {\n        gen.if(codegen_1._`${count} > ${max}`, () => gen.assign(valid, false).break());\n        if (min === 1) gen.assign(valid, true);else gen.if(codegen_1._`${count} >= ${min}`, () => gen.assign(valid, true));\n      }\n    }\n  }\n\n};\nexports.default = def;","map":null,"metadata":{},"sourceType":"script"}