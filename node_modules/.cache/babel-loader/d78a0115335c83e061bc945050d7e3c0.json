{"ast":null,"code":"'use strict';\n\nconst copyProperty = (to, from, property, ignoreNonConfigurable) => {\n  // `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n  // `Function#prototype` is non-writable and non-configurable so can never be modified.\n  if (property === 'length' || property === 'prototype') {\n    return;\n  } // `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\n\n  if (property === 'arguments' || property === 'caller') {\n    return;\n  }\n\n  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n    return;\n  }\n\n  Object.defineProperty(to, property, fromDescriptor);\n}; // `Object.defineProperty()` throws if the property exists, is not configurable and either:\n//  - one its descriptors is changed\n//  - it is non-writable and its value is changed\n\n\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n  return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);\n};\n\nconst changePrototype = (to, from) => {\n  const fromPrototype = Object.getPrototypeOf(from);\n\n  if (fromPrototype === Object.getPrototypeOf(to)) {\n    return;\n  }\n\n  Object.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name'); // We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\n\nconst changeToString = (to, from, name) => {\n  const withName = name === '' ? '' : `with ${name.trim()}() `;\n  const newToString = wrappedToString.bind(null, withName, from.toString()); // Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\n  Object.defineProperty(newToString, 'name', toStringName);\n  Object.defineProperty(to, 'toString', { ...toStringDescriptor,\n    value: newToString\n  });\n};\n\nconst mimicFn = (to, from, {\n  ignoreNonConfigurable = false\n} = {}) => {\n  const {\n    name\n  } = to;\n\n  for (const property of Reflect.ownKeys(from)) {\n    copyProperty(to, from, property, ignoreNonConfigurable);\n  }\n\n  changePrototype(to, from);\n  changeToString(to, from, name);\n  return to;\n};\n\nmodule.exports = mimicFn;","map":null,"metadata":{},"sourceType":"script"}