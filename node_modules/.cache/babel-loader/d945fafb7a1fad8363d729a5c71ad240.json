{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({\n    params\n  }) => codegen_1._`{passingSchemas: ${params.passing}}`\n};\nconst def = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      it\n    } = cxt;\n    /* istanbul ignore if */\n\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n    if (it.opts.discriminator && parentSchema.discriminator) return;\n    const schArr = schema;\n    const valid = gen.let(\"valid\", false);\n    const passing = gen.let(\"passing\", null);\n    const schValid = gen.name(\"_valid\");\n    cxt.setParams({\n      passing\n    }); // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf);\n    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n\n    function validateOneOf() {\n      schArr.forEach((sch, i) => {\n        let schCxt;\n\n        if (util_1.alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true);\n        } else {\n          schCxt = cxt.subschema({\n            keyword: \"oneOf\",\n            schemaProp: i,\n            compositeRule: true\n          }, schValid);\n        }\n\n        if (i > 0) {\n          gen.if(codegen_1._`${schValid} && ${valid}`).assign(valid, false).assign(passing, codegen_1._`[${passing}, ${i}]`).else();\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true);\n          gen.assign(passing, i);\n          if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name);\n        });\n      });\n    }\n  }\n\n};\nexports.default = def;","map":null,"metadata":{},"sourceType":"script"}