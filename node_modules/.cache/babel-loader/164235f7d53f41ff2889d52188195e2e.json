{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\n\nconst boolSchema_1 = require(\"./boolSchema\");\n\nconst dataType_1 = require(\"./dataType\");\n\nconst applicability_1 = require(\"./applicability\");\n\nconst dataType_2 = require(\"./dataType\");\n\nconst defaults_1 = require(\"./defaults\");\n\nconst keyword_1 = require(\"./keyword\");\n\nconst subschema_1 = require(\"./subschema\");\n\nconst codegen_1 = require(\"../codegen\");\n\nconst names_1 = require(\"../names\");\n\nconst resolve_1 = require(\"../resolve\");\n\nconst util_1 = require(\"../util\");\n\nconst errors_1 = require(\"../errors\"); // schema compilation - generates validation function, subschemaCode (below) is used for subschemas\n\n\nfunction validateFunctionCode(it) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it);\n      return;\n    }\n  }\n\n  validateFunction(it, () => boolSchema_1.topBoolOrEmptySchema(it));\n}\n\nexports.validateFunctionCode = validateFunctionCode;\n\nfunction validateFunction({\n  gen,\n  validateName,\n  schema,\n  schemaEnv,\n  opts\n}, body) {\n  if (opts.code.es5) {\n    gen.func(validateName, codegen_1._`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n      gen.code(codegen_1._`\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n      destructureValCxtES5(gen, opts);\n      gen.code(body);\n    });\n  } else {\n    gen.func(validateName, codegen_1._`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n  }\n}\n\nfunction destructureValCxt(opts) {\n  return codegen_1._`{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? codegen_1._`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\n\nfunction destructureValCxtES5(gen, opts) {\n  gen.if(names_1.default.valCxt, () => {\n    gen.var(names_1.default.instancePath, codegen_1._`${names_1.default.valCxt}.${names_1.default.instancePath}`);\n    gen.var(names_1.default.parentData, codegen_1._`${names_1.default.valCxt}.${names_1.default.parentData}`);\n    gen.var(names_1.default.parentDataProperty, codegen_1._`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n    gen.var(names_1.default.rootData, codegen_1._`${names_1.default.valCxt}.${names_1.default.rootData}`);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, codegen_1._`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n  }, () => {\n    gen.var(names_1.default.instancePath, codegen_1._`\"\"`);\n    gen.var(names_1.default.parentData, codegen_1._`undefined`);\n    gen.var(names_1.default.parentDataProperty, codegen_1._`undefined`);\n    gen.var(names_1.default.rootData, names_1.default.data);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, codegen_1._`{}`);\n  });\n}\n\nfunction topSchemaObjCode(it) {\n  const {\n    schema,\n    opts,\n    gen\n  } = it;\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it);\n    checkNoDefault(it);\n    gen.let(names_1.default.vErrors, null);\n    gen.let(names_1.default.errors, 0);\n    if (opts.unevaluated) resetEvaluated(it);\n    typeAndKeywords(it);\n    returnResults(it);\n  });\n  return;\n}\n\nfunction resetEvaluated(it) {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {\n    gen,\n    validateName\n  } = it;\n  it.evaluated = gen.const(\"evaluated\", codegen_1._`${validateName}.evaluated`);\n  gen.if(codegen_1._`${it.evaluated}.dynamicProps`, () => gen.assign(codegen_1._`${it.evaluated}.props`, codegen_1._`undefined`));\n  gen.if(codegen_1._`${it.evaluated}.dynamicItems`, () => gen.assign(codegen_1._`${it.evaluated}.items`, codegen_1._`undefined`));\n}\n\nfunction funcSourceUrl(schema, opts) {\n  return typeof schema == \"object\" && schema.$id && (opts.code.source || opts.code.process) ? codegen_1._`/*# sourceURL=${schema.$id} */` : codegen_1.nil;\n} // schema compilation - this function is used recursively to generate code for sub-schemas\n\n\nfunction subschemaCode(it, valid) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid);\n      return;\n    }\n  }\n\n  boolSchema_1.boolOrEmptySchema(it, valid);\n}\n\nfunction schemaCxtHasRules({\n  schema,\n  self\n}) {\n  if (typeof schema == \"boolean\") return !schema;\n\n  for (const key in schema) if (self.RULES.all[key]) return true;\n\n  return false;\n}\n\nfunction isSchemaObj(it) {\n  return typeof it.schema != \"boolean\";\n}\n\nfunction subSchemaObjCode(it, valid) {\n  const {\n    schema,\n    gen,\n    opts\n  } = it;\n  if (opts.$comment && schema.$comment) commentKeyword(it);\n  updateContext(it);\n  checkAsyncSchema(it);\n  const errsCount = gen.const(\"_errs\", names_1.default.errors);\n  typeAndKeywords(it, errsCount); // TODO var\n\n  gen.var(valid, codegen_1._`${errsCount} === ${names_1.default.errors}`);\n}\n\nfunction checkKeywords(it) {\n  util_1.checkUnknownRules(it);\n  checkRefsAndKeywords(it);\n}\n\nfunction typeAndKeywords(it, errsCount) {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);\n  const types = dataType_1.getSchemaTypes(it.schema);\n  const checkedTypes = dataType_1.coerceAndCheckDataType(it, types);\n  schemaKeywords(it, types, !checkedTypes, errsCount);\n}\n\nfunction checkRefsAndKeywords(it) {\n  const {\n    schema,\n    errSchemaPath,\n    opts,\n    self\n  } = it;\n\n  if (schema.$ref && opts.ignoreKeywordsWithRef && util_1.schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n  }\n}\n\nfunction checkNoDefault(it) {\n  const {\n    schema,\n    opts\n  } = it;\n\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    util_1.checkStrictMode(it, \"default is ignored in the schema root\");\n  }\n}\n\nfunction updateContext(it) {\n  if (it.schema.$id) it.baseId = resolve_1.resolveUrl(it.baseId, it.schema.$id);\n}\n\nfunction checkAsyncSchema(it) {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\");\n}\n\nfunction commentKeyword({\n  gen,\n  schemaEnv,\n  schema,\n  errSchemaPath,\n  opts\n}) {\n  const msg = schema.$comment;\n\n  if (opts.$comment === true) {\n    gen.code(codegen_1._`${names_1.default.self}.logger.log(${msg})`);\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = codegen_1.str`${errSchemaPath}/$comment`;\n    const rootName = gen.scopeValue(\"root\", {\n      ref: schemaEnv.root\n    });\n    gen.code(codegen_1._`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n  }\n}\n\nfunction returnResults(it) {\n  const {\n    gen,\n    schemaEnv,\n    validateName,\n    ValidationError,\n    opts\n  } = it;\n\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(codegen_1._`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw(codegen_1._`new ${ValidationError}(${names_1.default.vErrors})`));\n  } else {\n    gen.assign(codegen_1._`${validateName}.errors`, names_1.default.vErrors);\n    if (opts.unevaluated) assignEvaluated(it);\n    gen.return(codegen_1._`${names_1.default.errors} === 0`);\n  }\n}\n\nfunction assignEvaluated({\n  gen,\n  evaluated,\n  props,\n  items\n}) {\n  if (props instanceof codegen_1.Name) gen.assign(codegen_1._`${evaluated}.props`, props);\n  if (items instanceof codegen_1.Name) gen.assign(codegen_1._`${evaluated}.items`, items);\n}\n\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n  const {\n    gen,\n    schema,\n    data,\n    allErrors,\n    opts,\n    self\n  } = it;\n  const {\n    RULES\n  } = self;\n\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !util_1.schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n\n    return;\n  }\n\n  if (!opts.jtd) checkStrictTypes(it, types);\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group);\n\n    groupKeywords(RULES.post);\n  });\n\n  function groupKeywords(group) {\n    if (!applicability_1.shouldUseGroup(schema, group)) return;\n\n    if (group.type) {\n      gen.if(dataType_2.checkDataType(group.type, data, opts.strictNumbers));\n      iterateKeywords(it, group);\n\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else();\n        dataType_2.reportTypeError(it);\n      }\n\n      gen.endIf();\n    } else {\n      iterateKeywords(it, group);\n    } // TODO make it \"ok\" call?\n\n\n    if (!allErrors) gen.if(codegen_1._`${names_1.default.errors} === ${errsCount || 0}`);\n  }\n}\n\nfunction iterateKeywords(it, group) {\n  const {\n    gen,\n    schema,\n    opts: {\n      useDefaults\n    }\n  } = it;\n  if (useDefaults) defaults_1.assignDefaults(it, group.type);\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (applicability_1.shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type);\n      }\n    }\n  });\n}\n\nfunction checkStrictTypes(it, types) {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return;\n  checkContextTypes(it, types);\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);\n  checkKeywordTypes(it, it.dataTypes);\n}\n\nfunction checkContextTypes(it, types) {\n  if (!types.length) return;\n\n  if (!it.dataTypes.length) {\n    it.dataTypes = types;\n    return;\n  }\n\n  types.forEach(t => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n    }\n  });\n  it.dataTypes = it.dataTypes.filter(t => includesType(types, t));\n}\n\nfunction checkMultipleTypes(it, ts) {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n  }\n}\n\nfunction checkKeywordTypes(it, ts) {\n  const rules = it.self.RULES.all;\n\n  for (const keyword in rules) {\n    const rule = rules[keyword];\n\n    if (typeof rule == \"object\" && applicability_1.shouldUseRule(it.schema, rule)) {\n      const {\n        type\n      } = rule.definition;\n\n      if (type.length && !type.some(t => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs, kwdT) {\n  return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n}\n\nfunction includesType(ts, t) {\n  return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n}\n\nfunction strictTypesError(it, msg) {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n  msg += ` at \"${schemaPath}\" (strictTypes)`;\n  util_1.checkStrictMode(it, msg, it.opts.strictTypes);\n}\n\nclass KeywordCxt {\n  constructor(it, def, keyword) {\n    keyword_1.validateKeywordUsage(it, def, keyword);\n    this.gen = it.gen;\n    this.allErrors = it.allErrors;\n    this.keyword = keyword;\n    this.data = it.data;\n    this.schema = it.schema[keyword];\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n    this.schemaValue = util_1.schemaRefOrVal(it, this.schema, keyword, this.$data);\n    this.schemaType = def.schemaType;\n    this.parentSchema = it.schema;\n    this.params = {};\n    this.it = it;\n    this.def = def;\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n    } else {\n      this.schemaCode = this.schemaValue;\n\n      if (!keyword_1.validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n    }\n  }\n\n  result(condition, successAction, failAction) {\n    this.gen.if(codegen_1.not(condition));\n    if (failAction) failAction();else this.error();\n\n    if (successAction) {\n      this.gen.else();\n      successAction();\n      if (this.allErrors) this.gen.endIf();\n    } else {\n      if (this.allErrors) this.gen.endIf();else this.gen.else();\n    }\n  }\n\n  pass(condition, failAction) {\n    this.result(condition, undefined, failAction);\n  }\n\n  fail(condition) {\n    if (condition === undefined) {\n      this.error();\n      if (!this.allErrors) this.gen.if(false); // this branch will be removed by gen.optimize\n\n      return;\n    }\n\n    this.gen.if(condition);\n    this.error();\n    if (this.allErrors) this.gen.endIf();else this.gen.else();\n  }\n\n  fail$data(condition) {\n    if (!this.$data) return this.fail(condition);\n    const {\n      schemaCode\n    } = this;\n    this.fail(codegen_1._`${schemaCode} !== undefined && (${codegen_1.or(this.invalid$data(), condition)})`);\n  }\n\n  error(append, errorParams, errorPaths) {\n    if (errorParams) {\n      this.setParams(errorParams);\n\n      this._error(append, errorPaths);\n\n      this.setParams({});\n      return;\n    }\n\n    this._error(append, errorPaths);\n  }\n\n  _error(append, errorPaths) {\n    ;\n    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n  }\n\n  $dataError() {\n    errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);\n  }\n\n  reset() {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition');\n    errors_1.resetErrorsCount(this.gen, this.errsCount);\n  }\n\n  ok(cond) {\n    if (!this.allErrors) this.gen.if(cond);\n  }\n\n  setParams(obj, assign) {\n    if (assign) Object.assign(this.params, obj);else this.params = obj;\n  }\n\n  block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid);\n      codeBlock();\n    });\n  }\n\n  check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n    if (!this.$data) return;\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def\n    } = this;\n    gen.if(codegen_1.or(codegen_1._`${schemaCode} === undefined`, $dataValid));\n    if (valid !== codegen_1.nil) gen.assign(valid, true);\n\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data());\n      this.$dataError();\n      if (valid !== codegen_1.nil) gen.assign(valid, false);\n    }\n\n    gen.else();\n  }\n\n  invalid$data() {\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def,\n      it\n    } = this;\n    return codegen_1.or(wrong$DataType(), invalid$DataSchema());\n\n    function wrong$DataType() {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof codegen_1.Name)) throw new Error(\"ajv implementation error\");\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n        return codegen_1._`${dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n      }\n\n      return codegen_1.nil;\n    }\n\n    function invalid$DataSchema() {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {\n          ref: def.validateSchema\n        }); // TODO value.code for standalone\n\n        return codegen_1._`!${validateSchemaRef}(${schemaCode})`;\n      }\n\n      return codegen_1.nil;\n    }\n  }\n\n  subschema(appl, valid) {\n    const subschema = subschema_1.getSubschema(this.it, appl);\n    subschema_1.extendSubschemaData(subschema, this.it, appl);\n    subschema_1.extendSubschemaMode(subschema, appl);\n    const nextContext = { ...this.it,\n      ...subschema,\n      items: undefined,\n      props: undefined\n    };\n    subschemaCode(nextContext, valid);\n    return nextContext;\n  }\n\n  mergeEvaluated(schemaCxt, toName) {\n    const {\n      it,\n      gen\n    } = this;\n    if (!it.opts.unevaluated) return;\n\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n    }\n\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt, valid) {\n    const {\n      it,\n      gen\n    } = this;\n\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n      return true;\n    }\n  }\n\n}\n\nexports.KeywordCxt = KeywordCxt;\n\nfunction keywordCode(it, keyword, def, ruleType) {\n  const cxt = new KeywordCxt(it, def, keyword);\n\n  if (\"code\" in def) {\n    def.code(cxt, ruleType);\n  } else if (cxt.$data && def.validate) {\n    keyword_1.funcKeywordCode(cxt, def);\n  } else if (\"macro\" in def) {\n    keyword_1.macroKeywordCode(cxt, def);\n  } else if (def.compile || def.validate) {\n    keyword_1.funcKeywordCode(cxt, def);\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\n\nfunction getData($data, {\n  dataLevel,\n  dataNames,\n  dataPathArr\n}) {\n  let jsonPointer;\n  let data;\n  if ($data === \"\") return names_1.default.rootData;\n\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);\n    jsonPointer = $data;\n    data = names_1.default.rootData;\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data);\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);\n    const up = +matches[1];\n    jsonPointer = matches[2];\n\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up));\n      return dataPathArr[dataLevel - up];\n    }\n\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up));\n    data = dataNames[dataLevel - up];\n    if (!jsonPointer) return data;\n  }\n\n  let expr = data;\n  const segments = jsonPointer.split(\"/\");\n\n  for (const segment of segments) {\n    if (segment) {\n      data = codegen_1._`${data}${codegen_1.getProperty(util_1.unescapeJsonPointer(segment))}`;\n      expr = codegen_1._`${expr} && ${data}`;\n    }\n  }\n\n  return expr;\n\n  function errorMsg(pointerType, up) {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n  }\n}\n\nexports.getData = getData;","map":null,"metadata":{},"sourceType":"script"}