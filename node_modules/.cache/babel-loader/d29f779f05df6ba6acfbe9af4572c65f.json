{"ast":null,"code":"'use strict';\n\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n} // The input can also be a promise, so we `Promise.resolve()` it\n\n\nconst testElement = (el, tester) => Promise.resolve(el).then(tester); // The input can also be a promise, so we `Promise.all()` them both\n\n\nconst finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));\n\nmodule.exports = (iterable, tester, opts) => {\n  opts = Object.assign({\n    concurrency: Infinity,\n    preserveOrder: true\n  }, opts);\n  const limit = pLimit(opts.concurrency); // Start all the promises concurrently with optional limit\n\n  const items = [...iterable].map(el => [el, limit(testElement, el, tester)]); // Check the promises either serially or concurrently\n\n  const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);\n  return Promise.all(items.map(el => checkLimit(finder, el))).then(() => {}).catch(err => err instanceof EndError ? err.value : Promise.reject(err));\n};","map":null,"metadata":{},"sourceType":"script"}