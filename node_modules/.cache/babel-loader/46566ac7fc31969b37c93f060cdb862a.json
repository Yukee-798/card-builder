{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst code_1 = require(\"../code\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst util_2 = require(\"../../compile/util\");\n\nconst def = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      data,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      opts\n    } = it;\n    const patterns = code_1.schemaProperties(it, schema); // TODO mark properties matching patterns with always valid schemas as evaluated\n\n    if (patterns.length === 0) return;\n    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n    const valid = gen.name(\"valid\");\n\n    if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n      it.props = util_2.evaluatedPropsToName(gen, it.props);\n    }\n\n    const {\n      props\n    } = it;\n    validatePatternProperties();\n\n    function validatePatternProperties() {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat);\n\n        if (it.allErrors) {\n          validateProperties(pat);\n        } else {\n          gen.var(valid, true); // TODO var\n\n          validateProperties(pat);\n          gen.if(valid);\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat) {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          util_1.checkStrictMode(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n        }\n      }\n    }\n\n    function validateProperties(pat) {\n      gen.forIn(\"key\", data, key => {\n        gen.if(codegen_1._`${code_1.usePattern(cxt, pat)}.test(${key})`, () => {\n          cxt.subschema({\n            keyword: \"patternProperties\",\n            schemaProp: pat,\n            dataProp: key,\n            dataPropType: util_2.Type.Str\n          }, valid);\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(codegen_1._`${props}[${key}]`, true);\n          } else if (!it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(codegen_1.not(valid), () => gen.break());\n          }\n        });\n      });\n    }\n  }\n\n};\nexports.default = def;","map":null,"metadata":{},"sourceType":"script"}