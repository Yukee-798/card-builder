{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\n\nconst rules_1 = require(\"../rules\");\n\nconst applicability_1 = require(\"./applicability\");\n\nconst errors_1 = require(\"../errors\");\n\nconst codegen_1 = require(\"../codegen\");\n\nconst util_1 = require(\"../util\");\n\nvar DataType;\n\n(function (DataType) {\n  DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n  DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType = exports.DataType || (exports.DataType = {}));\n\nfunction getSchemaTypes(schema) {\n  const types = getJSONTypes(schema.type);\n  const hasNull = types.includes(\"null\");\n\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\");\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"');\n    }\n\n    if (schema.nullable === true) types.push(\"null\");\n  }\n\n  return types;\n}\n\nexports.getSchemaTypes = getSchemaTypes;\n\nfunction getJSONTypes(ts) {\n  const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n  if (types.every(rules_1.isJSONType)) return types;\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\n\nexports.getJSONTypes = getJSONTypes;\n\nfunction coerceAndCheckDataType(it, types) {\n  const {\n    gen,\n    data,\n    opts\n  } = it;\n  const coerceTo = coerceToTypes(types, opts.coerceTypes);\n  const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && applicability_1.schemaHasRulesForType(it, types[0]));\n\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo);else reportTypeError(it);\n    });\n  }\n\n  return checkTypes;\n}\n\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\n\nfunction coerceToTypes(types, coerceTypes) {\n  return coerceTypes ? types.filter(t => COERCIBLE.has(t) || coerceTypes === \"array\" && t === \"array\") : [];\n}\n\nfunction coerceData(it, types, coerceTo) {\n  const {\n    gen,\n    data,\n    opts\n  } = it;\n  const dataType = gen.let(\"dataType\", codegen_1._`typeof ${data}`);\n  const coerced = gen.let(\"coerced\", codegen_1._`undefined`);\n\n  if (opts.coerceTypes === \"array\") {\n    gen.if(codegen_1._`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, codegen_1._`${data}[0]`).assign(dataType, codegen_1._`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n  }\n\n  gen.if(codegen_1._`${coerced} !== undefined`);\n\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || t === \"array\" && opts.coerceTypes === \"array\") {\n      coerceSpecificType(t);\n    }\n  }\n\n  gen.else();\n  reportTypeError(it);\n  gen.endIf();\n  gen.if(codegen_1._`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced);\n    assignParentData(it, coerced);\n  });\n\n  function coerceSpecificType(t) {\n    switch (t) {\n      case \"string\":\n        gen.elseIf(codegen_1._`${dataType} == \"number\" || ${dataType} == \"boolean\"`).assign(coerced, codegen_1._`\"\" + ${data}`).elseIf(codegen_1._`${data} === null`).assign(coerced, codegen_1._`\"\"`);\n        return;\n\n      case \"number\":\n        gen.elseIf(codegen_1._`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`).assign(coerced, codegen_1._`+${data}`);\n        return;\n\n      case \"integer\":\n        gen.elseIf(codegen_1._`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, codegen_1._`+${data}`);\n        return;\n\n      case \"boolean\":\n        gen.elseIf(codegen_1._`${data} === \"false\" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf(codegen_1._`${data} === \"true\" || ${data} === 1`).assign(coerced, true);\n        return;\n\n      case \"null\":\n        gen.elseIf(codegen_1._`${data} === \"\" || ${data} === 0 || ${data} === false`);\n        gen.assign(coerced, null);\n        return;\n\n      case \"array\":\n        gen.elseIf(codegen_1._`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`).assign(coerced, codegen_1._`[${data}]`);\n    }\n  }\n}\n\nfunction assignParentData({\n  gen,\n  parentData,\n  parentDataProperty\n}, expr) {\n  // TODO use gen.property\n  gen.if(codegen_1._`${parentData} !== undefined`, () => gen.assign(codegen_1._`${parentData}[${parentDataProperty}]`, expr));\n}\n\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n  const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n  let cond;\n\n  switch (dataType) {\n    case \"null\":\n      return codegen_1._`${data} ${EQ} null`;\n\n    case \"array\":\n      cond = codegen_1._`Array.isArray(${data})`;\n      break;\n\n    case \"object\":\n      cond = codegen_1._`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n      break;\n\n    case \"integer\":\n      cond = numCond(codegen_1._`!(${data} % 1) && !isNaN(${data})`);\n      break;\n\n    case \"number\":\n      cond = numCond();\n      break;\n\n    default:\n      return codegen_1._`typeof ${data} ${EQ} ${dataType}`;\n  }\n\n  return correct === DataType.Correct ? cond : codegen_1.not(cond);\n\n  function numCond(_cond = codegen_1.nil) {\n    return codegen_1.and(codegen_1._`typeof ${data} == \"number\"`, _cond, strictNums ? codegen_1._`isFinite(${data})` : codegen_1.nil);\n  }\n}\n\nexports.checkDataType = checkDataType;\n\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct);\n  }\n\n  let cond;\n  const types = util_1.toHash(dataTypes);\n\n  if (types.array && types.object) {\n    const notObj = codegen_1._`typeof ${data} != \"object\"`;\n    cond = types.null ? notObj : codegen_1._`!${data} || ${notObj}`;\n    delete types.null;\n    delete types.array;\n    delete types.object;\n  } else {\n    cond = codegen_1.nil;\n  }\n\n  if (types.number) delete types.integer;\n\n  for (const t in types) cond = codegen_1.and(cond, checkDataType(t, data, strictNums, correct));\n\n  return cond;\n}\n\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n  message: ({\n    schema\n  }) => `must be ${schema}`,\n  params: ({\n    schema,\n    schemaValue\n  }) => typeof schema == \"string\" ? codegen_1._`{type: ${schema}}` : codegen_1._`{type: ${schemaValue}}`\n};\n\nfunction reportTypeError(it) {\n  const cxt = getTypeErrorContext(it);\n  errors_1.reportError(cxt, typeError);\n}\n\nexports.reportTypeError = reportTypeError;\n\nfunction getTypeErrorContext(it) {\n  const {\n    gen,\n    data,\n    schema\n  } = it;\n  const schemaCode = util_1.schemaRefOrVal(it, schema, \"type\");\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it\n  };\n}","map":null,"metadata":{},"sourceType":"script"}