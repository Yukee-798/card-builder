{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateAdditionalItems = void 0;\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: ({\n    params: {\n      len\n    }\n  }) => codegen_1.str`must NOT have more than ${len} items`,\n  params: ({\n    params: {\n      len\n    }\n  }) => codegen_1._`{limit: ${len}}`\n};\nconst def = {\n  keyword: \"additionalItems\",\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n\n  code(cxt) {\n    const {\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      items\n    } = parentSchema;\n\n    if (!Array.isArray(items)) {\n      util_1.checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n      return;\n    }\n\n    validateAdditionalItems(cxt, items);\n  }\n\n};\n\nfunction validateAdditionalItems(cxt, items) {\n  const {\n    gen,\n    schema,\n    data,\n    keyword,\n    it\n  } = cxt;\n  it.items = true;\n  const len = gen.const(\"len\", codegen_1._`${data}.length`);\n\n  if (schema === false) {\n    cxt.setParams({\n      len: items.length\n    });\n    cxt.pass(codegen_1._`${len} <= ${items.length}`);\n  } else if (typeof schema == \"object\" && !util_1.alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", codegen_1._`${len} <= ${items.length}`); // TODO var\n\n    gen.if(codegen_1.not(valid), () => validateItems(valid));\n    cxt.ok(valid);\n  }\n\n  function validateItems(valid) {\n    gen.forRange(\"i\", items.length, len, i => {\n      cxt.subschema({\n        keyword,\n        dataProp: i,\n        dataPropType: util_1.Type.Num\n      }, valid);\n      if (!it.allErrors) gen.if(codegen_1.not(valid), () => gen.break());\n    });\n  }\n}\n\nexports.validateAdditionalItems = validateAdditionalItems;\nexports.default = def;","map":null,"metadata":{},"sourceType":"script"}