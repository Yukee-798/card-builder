{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\n\nconst codegen_1 = require(\"./codegen\");\n\nconst validation_error_1 = require(\"../runtime/validation_error\");\n\nconst names_1 = require(\"./names\");\n\nconst resolve_1 = require(\"./resolve\");\n\nconst util_1 = require(\"./util\");\n\nconst validate_1 = require(\"./validate\");\n\nconst URI = require(\"uri-js\");\n\nclass SchemaEnv {\n  constructor(env) {\n    var _a;\n\n    this.refs = {};\n    this.dynamicAnchors = {};\n    let schema;\n    if (typeof env.schema == \"object\") schema = env.schema;\n    this.schema = env.schema;\n    this.root = env.root || this;\n    this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : resolve_1.normalizeId(schema === null || schema === void 0 ? void 0 : schema.$id);\n    this.schemaPath = env.schemaPath;\n    this.localRefs = env.localRefs;\n    this.meta = env.meta;\n    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n    this.refs = {};\n  }\n\n}\n\nexports.SchemaEnv = SchemaEnv; // let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\n\nfunction compileSchema(sch) {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch);\n\n  if (_sch) return _sch;\n  const rootId = resolve_1.getFullPath(sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n\n  const {\n    es5,\n    lines\n  } = this.opts.code;\n  const {\n    ownProperties\n  } = this.opts;\n  const gen = new codegen_1.CodeGen(this.scope, {\n    es5,\n    lines,\n    ownProperties\n  });\n\n  let _ValidationError;\n\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: validation_error_1.default,\n      code: codegen_1._`require(\"ajv/dist/runtime/validation_error\").default`\n    });\n  }\n\n  const validateName = gen.scopeName(\"validate\");\n  sch.validateName = validateName;\n  const schemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: names_1.default.data,\n    parentData: names_1.default.parentData,\n    parentDataProperty: names_1.default.parentDataProperty,\n    dataNames: [names_1.default.data],\n    dataPathArr: [codegen_1.nil],\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set(),\n    topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true ? {\n      ref: sch.schema,\n      code: codegen_1.stringify(sch.schema)\n    } : {\n      ref: sch.schema\n    }),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: codegen_1._`\"\"`,\n    opts: this.opts,\n    self: this\n  };\n  let sourceCode;\n\n  try {\n    this._compilations.add(sch);\n\n    validate_1.validateFunctionCode(schemaCxt);\n    gen.optimize(this.opts.code.optimize); // gen.optimize(1)\n\n    const validateCode = gen.toString();\n    sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`; // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch); // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n\n    const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n    const validate = makeValidate(this, this.scope.get());\n    this.scope.value(validateName, {\n      ref: validate\n    });\n    validate.errors = null;\n    validate.schema = sch.schema;\n    validate.schemaEnv = sch;\n    if (sch.$async) validate.$async = true;\n\n    if (this.opts.code.source === true) {\n      validate.source = {\n        validateName,\n        validateCode,\n        scopeValues: gen._values\n      };\n    }\n\n    if (this.opts.unevaluated) {\n      const {\n        props,\n        items\n      } = schemaCxt;\n      validate.evaluated = {\n        props: props instanceof codegen_1.Name ? undefined : props,\n        items: items instanceof codegen_1.Name ? undefined : items,\n        dynamicProps: props instanceof codegen_1.Name,\n        dynamicItems: items instanceof codegen_1.Name\n      };\n      if (validate.source) validate.source.evaluated = codegen_1.stringify(validate.evaluated);\n    }\n\n    sch.validate = validate;\n    return sch;\n  } catch (e) {\n    delete sch.validate;\n    delete sch.validateName;\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode); // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n\n    throw e;\n  } finally {\n    this._compilations.delete(sch);\n  }\n}\n\nexports.compileSchema = compileSchema;\n\nfunction resolveRef(root, baseId, ref) {\n  var _a;\n\n  ref = resolve_1.resolveUrl(baseId, ref);\n  const schOrFunc = root.refs[ref];\n  if (schOrFunc) return schOrFunc;\n\n  let _sch = resolve.call(this, root, ref);\n\n  if (_sch === undefined) {\n    const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n\n    if (schema) _sch = new SchemaEnv({\n      schema,\n      root,\n      baseId\n    });\n  }\n\n  if (_sch === undefined) return;\n  return root.refs[ref] = inlineOrCompile.call(this, _sch);\n}\n\nexports.resolveRef = resolveRef;\n\nfunction inlineOrCompile(sch) {\n  if (resolve_1.inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema;\n  return sch.validate ? sch : compileSchema.call(this, sch);\n} // Index of schema compilation in the currently compiled list\n\n\nfunction getCompilingSchema(schEnv) {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch;\n  }\n}\n\nexports.getCompilingSchema = getCompilingSchema;\n\nfunction sameSchemaEnv(s1, s2) {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n} // resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\n\n\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n  let sch;\n\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch;\n\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n} // Resolve schema, its root and baseId\n\n\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n  const p = URI.parse(ref);\n\n  const refPath = resolve_1._getFullPath(p);\n\n  let baseId = resolve_1.getFullPath(root.baseId); // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root);\n  }\n\n  const id = resolve_1.normalizeId(refPath);\n  const schOrRef = this.refs[id] || this.schemas[id];\n\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef);\n    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\") return;\n    return getJsonPointer.call(this, p, sch);\n  }\n\n  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\") return;\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef);\n\n  if (id === resolve_1.normalizeId(ref)) {\n    const {\n      schema\n    } = schOrRef;\n    if (schema.$id) baseId = resolve_1.resolveUrl(baseId, schema.$id);\n    return new SchemaEnv({\n      schema,\n      root,\n      baseId\n    });\n  }\n\n  return getJsonPointer.call(this, p, schOrRef);\n}\n\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\"properties\", \"patternProperties\", \"enum\", \"dependencies\", \"definitions\"]);\n\nfunction getJsonPointer(parsedRef, {\n  baseId,\n  schema,\n  root\n}) {\n  var _a;\n\n  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\") return;\n\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema == \"boolean\") return;\n    schema = schema[util_1.unescapeFragment(part)];\n    if (schema === undefined) return; // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n\n    if (!PREVENT_SCOPE_CHANGE.has(part) && typeof schema == \"object\" && schema.$id) {\n      baseId = resolve_1.resolveUrl(baseId, schema.$id);\n    }\n  }\n\n  let env;\n\n  if (typeof schema != \"boolean\" && schema.$ref && !util_1.schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolve_1.resolveUrl(baseId, schema.$ref);\n    env = resolveSchema.call(this, root, $ref);\n  } // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n\n\n  env = env || new SchemaEnv({\n    schema,\n    root,\n    baseId\n  });\n  if (env.schema !== env.root.schema) return env;\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"script"}