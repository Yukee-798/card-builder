{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\n\nconst code_1 = require(\"./code\");\n\nconst scope_1 = require(\"./scope\");\n\nvar code_2 = require(\"./code\");\n\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function () {\n    return code_2._;\n  }\n});\nObject.defineProperty(exports, \"str\", {\n  enumerable: true,\n  get: function () {\n    return code_2.str;\n  }\n});\nObject.defineProperty(exports, \"strConcat\", {\n  enumerable: true,\n  get: function () {\n    return code_2.strConcat;\n  }\n});\nObject.defineProperty(exports, \"nil\", {\n  enumerable: true,\n  get: function () {\n    return code_2.nil;\n  }\n});\nObject.defineProperty(exports, \"getProperty\", {\n  enumerable: true,\n  get: function () {\n    return code_2.getProperty;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return code_2.stringify;\n  }\n});\nObject.defineProperty(exports, \"regexpCode\", {\n  enumerable: true,\n  get: function () {\n    return code_2.regexpCode;\n  }\n});\nObject.defineProperty(exports, \"Name\", {\n  enumerable: true,\n  get: function () {\n    return code_2.Name;\n  }\n});\n\nvar scope_2 = require(\"./scope\");\n\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.Scope;\n  }\n});\nObject.defineProperty(exports, \"ValueScope\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.ValueScope;\n  }\n});\nObject.defineProperty(exports, \"ValueScopeName\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.ValueScopeName;\n  }\n});\nObject.defineProperty(exports, \"varKinds\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.varKinds;\n  }\n});\nexports.operators = {\n  GT: new code_1._Code(\">\"),\n  GTE: new code_1._Code(\">=\"),\n  LT: new code_1._Code(\"<\"),\n  LTE: new code_1._Code(\"<=\"),\n  EQ: new code_1._Code(\"===\"),\n  NEQ: new code_1._Code(\"!==\"),\n  NOT: new code_1._Code(\"!\"),\n  OR: new code_1._Code(\"||\"),\n  AND: new code_1._Code(\"&&\"),\n  ADD: new code_1._Code(\"+\")\n};\n\nclass Node {\n  optimizeNodes() {\n    return this;\n  }\n\n  optimizeNames(_names, _constants) {\n    return this;\n  }\n\n}\n\nclass Def extends Node {\n  constructor(varKind, name, rhs) {\n    super();\n    this.varKind = varKind;\n    this.name = name;\n    this.rhs = rhs;\n  }\n\n  render({\n    es5,\n    _n\n  }) {\n    const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n    return `${varKind} ${this.name}${rhs};` + _n;\n  }\n\n  optimizeNames(names, constants) {\n    if (!names[this.name.str]) return;\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants);\n    return this;\n  }\n\n  get names() {\n    return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n  }\n\n}\n\nclass Assign extends Node {\n  constructor(lhs, rhs, sideEffects) {\n    super();\n    this.lhs = lhs;\n    this.rhs = rhs;\n    this.sideEffects = sideEffects;\n  }\n\n  render({\n    _n\n  }) {\n    return `${this.lhs} = ${this.rhs};` + _n;\n  }\n\n  optimizeNames(names, constants) {\n    if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects) return;\n    this.rhs = optimizeExpr(this.rhs, names, constants);\n    return this;\n  }\n\n  get names() {\n    const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names\n    };\n    return addExprNames(names, this.rhs);\n  }\n\n}\n\nclass AssignOp extends Assign {\n  constructor(lhs, op, rhs, sideEffects) {\n    super(lhs, rhs, sideEffects);\n    this.op = op;\n  }\n\n  render({\n    _n\n  }) {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n  }\n\n}\n\nclass Label extends Node {\n  constructor(label) {\n    super();\n    this.label = label;\n    this.names = {};\n  }\n\n  render({\n    _n\n  }) {\n    return `${this.label}:` + _n;\n  }\n\n}\n\nclass Break extends Node {\n  constructor(label) {\n    super();\n    this.label = label;\n    this.names = {};\n  }\n\n  render({\n    _n\n  }) {\n    const label = this.label ? ` ${this.label}` : \"\";\n    return `break${label};` + _n;\n  }\n\n}\n\nclass Throw extends Node {\n  constructor(error) {\n    super();\n    this.error = error;\n  }\n\n  render({\n    _n\n  }) {\n    return `throw ${this.error};` + _n;\n  }\n\n  get names() {\n    return this.error.names;\n  }\n\n}\n\nclass AnyCode extends Node {\n  constructor(code) {\n    super();\n    this.code = code;\n  }\n\n  render({\n    _n\n  }) {\n    return `${this.code};` + _n;\n  }\n\n  optimizeNodes() {\n    return `${this.code}` ? this : undefined;\n  }\n\n  optimizeNames(names, constants) {\n    this.code = optimizeExpr(this.code, names, constants);\n    return this;\n  }\n\n  get names() {\n    return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n  }\n\n}\n\nclass ParentNode extends Node {\n  constructor(nodes = []) {\n    super();\n    this.nodes = nodes;\n  }\n\n  render(opts) {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n  }\n\n  optimizeNodes() {\n    const {\n      nodes\n    } = this;\n    let i = nodes.length;\n\n    while (i--) {\n      const n = nodes[i].optimizeNodes();\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n);else if (n) nodes[i] = n;else nodes.splice(i, 1);\n    }\n\n    return nodes.length > 0 ? this : undefined;\n  }\n\n  optimizeNames(names, constants) {\n    const {\n      nodes\n    } = this;\n    let i = nodes.length;\n\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i];\n      if (n.optimizeNames(names, constants)) continue;\n      subtractNames(names, n.names);\n      nodes.splice(i, 1);\n    }\n\n    return nodes.length > 0 ? this : undefined;\n  }\n\n  get names() {\n    return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n  }\n\n}\n\nclass BlockNode extends ParentNode {\n  render(opts) {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n  }\n\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {}\n\nElse.kind = \"else\";\n\nclass If extends BlockNode {\n  constructor(condition, nodes) {\n    super(nodes);\n    this.condition = condition;\n  }\n\n  render(opts) {\n    let code = `if(${this.condition})` + super.render(opts);\n    if (this.else) code += \"else \" + this.else.render(opts);\n    return code;\n  }\n\n  optimizeNodes() {\n    super.optimizeNodes();\n    const cond = this.condition;\n    if (cond === true) return this.nodes; // else is ignored here\n\n    let e = this.else;\n\n    if (e) {\n      const ns = e.optimizeNodes();\n      e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n    }\n\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes;\n      if (this.nodes.length) return this;\n      return new If(not(cond), e instanceof If ? [e] : e.nodes);\n    }\n\n    if (cond === false || !this.nodes.length) return undefined;\n    return this;\n  }\n\n  optimizeNames(names, constants) {\n    var _a;\n\n    this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n    if (!(super.optimizeNames(names, constants) || this.else)) return;\n    this.condition = optimizeExpr(this.condition, names, constants);\n    return this;\n  }\n\n  get names() {\n    const names = super.names;\n    addExprNames(names, this.condition);\n    if (this.else) addNames(names, this.else.names);\n    return names;\n  }\n\n}\n\nIf.kind = \"if\";\n\nclass For extends BlockNode {}\n\nFor.kind = \"for\";\n\nclass ForLoop extends For {\n  constructor(iteration) {\n    super();\n    this.iteration = iteration;\n  }\n\n  render(opts) {\n    return `for(${this.iteration})` + super.render(opts);\n  }\n\n  optimizeNames(names, constants) {\n    if (!super.optimizeNames(names, constants)) return;\n    this.iteration = optimizeExpr(this.iteration, names, constants);\n    return this;\n  }\n\n  get names() {\n    return addNames(super.names, this.iteration.names);\n  }\n\n}\n\nclass ForRange extends For {\n  constructor(varKind, name, from, to) {\n    super();\n    this.varKind = varKind;\n    this.name = name;\n    this.from = from;\n    this.to = to;\n  }\n\n  render(opts) {\n    const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n    const {\n      name,\n      from,\n      to\n    } = this;\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n  }\n\n  get names() {\n    const names = addExprNames(super.names, this.from);\n    return addExprNames(names, this.to);\n  }\n\n}\n\nclass ForIter extends For {\n  constructor(loop, varKind, name, iterable) {\n    super();\n    this.loop = loop;\n    this.varKind = varKind;\n    this.name = name;\n    this.iterable = iterable;\n  }\n\n  render(opts) {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n  }\n\n  optimizeNames(names, constants) {\n    if (!super.optimizeNames(names, constants)) return;\n    this.iterable = optimizeExpr(this.iterable, names, constants);\n    return this;\n  }\n\n  get names() {\n    return addNames(super.names, this.iterable.names);\n  }\n\n}\n\nclass Func extends BlockNode {\n  constructor(name, args, async) {\n    super();\n    this.name = name;\n    this.args = args;\n    this.async = async;\n  }\n\n  render(opts) {\n    const _async = this.async ? \"async \" : \"\";\n\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n  }\n\n}\n\nFunc.kind = \"func\";\n\nclass Return extends ParentNode {\n  render(opts) {\n    return \"return \" + super.render(opts);\n  }\n\n}\n\nReturn.kind = \"return\";\n\nclass Try extends BlockNode {\n  render(opts) {\n    let code = \"try\" + super.render(opts);\n    if (this.catch) code += this.catch.render(opts);\n    if (this.finally) code += this.finally.render(opts);\n    return code;\n  }\n\n  optimizeNodes() {\n    var _a, _b;\n\n    super.optimizeNodes();\n    (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n    (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n    return this;\n  }\n\n  optimizeNames(names, constants) {\n    var _a, _b;\n\n    super.optimizeNames(names, constants);\n    (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n    (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n    return this;\n  }\n\n  get names() {\n    const names = super.names;\n    if (this.catch) addNames(names, this.catch.names);\n    if (this.finally) addNames(names, this.finally.names);\n    return names;\n  }\n\n}\n\nclass Catch extends BlockNode {\n  constructor(error) {\n    super();\n    this.error = error;\n  }\n\n  render(opts) {\n    return `catch(${this.error})` + super.render(opts);\n  }\n\n}\n\nCatch.kind = \"catch\";\n\nclass Finally extends BlockNode {\n  render(opts) {\n    return \"finally\" + super.render(opts);\n  }\n\n}\n\nFinally.kind = \"finally\";\n\nclass CodeGen {\n  constructor(extScope, opts = {}) {\n    this._values = {};\n    this._blockStarts = [];\n    this._constants = {};\n    this.opts = { ...opts,\n      _n: opts.lines ? \"\\n\" : \"\"\n    };\n    this._extScope = extScope;\n    this._scope = new scope_1.Scope({\n      parent: extScope\n    });\n    this._nodes = [new Root()];\n  }\n\n  toString() {\n    return this._root.render(this.opts);\n  } // returns unique name in the internal scope\n\n\n  name(prefix) {\n    return this._scope.name(prefix);\n  } // reserves unique name in the external scope\n\n\n  scopeName(prefix) {\n    return this._extScope.name(prefix);\n  } // reserves unique name in the external scope and assigns value to it\n\n\n  scopeValue(prefixOrName, value) {\n    const name = this._extScope.value(prefixOrName, value);\n\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n    vs.add(name);\n    return name;\n  }\n\n  getScopeValue(prefix, keyOrRef) {\n    return this._extScope.getValue(prefix, keyOrRef);\n  } // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n\n\n  scopeRefs(scopeName) {\n    return this._extScope.scopeRefs(scopeName, this._values);\n  }\n\n  scopeCode() {\n    return this._extScope.scopeCode(this._values);\n  }\n\n  _def(varKind, nameOrPrefix, rhs, constant) {\n    const name = this._scope.toName(nameOrPrefix);\n\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs;\n\n    this._leafNode(new Def(varKind, name, rhs));\n\n    return name;\n  } // `const` declaration (`var` in es5 mode)\n\n\n  const(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n  } // `let` declaration with optional assignment (`var` in es5 mode)\n\n\n  let(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n  } // `var` declaration with optional assignment\n\n\n  var(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n  } // assignment code\n\n\n  assign(lhs, rhs, sideEffects) {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects));\n  } // `+=` code\n\n\n  add(lhs, rhs) {\n    return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n  } // appends passed SafeExpr to code or executes Block\n\n\n  code(c) {\n    if (typeof c == \"function\") c();else if (c !== code_1.nil) this._leafNode(new AnyCode(c));\n    return this;\n  } // returns code for object literal for the passed argument list of key-value pairs\n\n\n  object(...keyValues) {\n    const code = [\"{\"];\n\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\");\n      code.push(key);\n\n      if (key !== value || this.opts.es5) {\n        code.push(\":\");\n        code_1.addCodeArg(code, value);\n      }\n    }\n\n    code.push(\"}\");\n    return new code_1._Code(code);\n  } // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n\n\n  if(condition, thenBody, elseBody) {\n    this._blockNode(new If(condition));\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf();\n    } else if (thenBody) {\n      this.code(thenBody).endIf();\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body');\n    }\n\n    return this;\n  } // `else if` clause - invalid without `if` or after `else` clauses\n\n\n  elseIf(condition) {\n    return this._elseNode(new If(condition));\n  } // `else` clause - only valid after `if` or `else if` clauses\n\n\n  else() {\n    return this._elseNode(new Else());\n  } // end `if` statement (needed if gen.if was used only with condition)\n\n\n  endIf() {\n    return this._endBlockNode(If, Else);\n  }\n\n  _for(node, forBody) {\n    this._blockNode(node);\n\n    if (forBody) this.code(forBody).endFor();\n    return this;\n  } // a generic `for` clause (or statement if `forBody` is passed)\n\n\n  for(iteration, forBody) {\n    return this._for(new ForLoop(iteration), forBody);\n  } // `for` statement for a range of values\n\n\n  forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {\n    const name = this._scope.toName(nameOrPrefix);\n\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n  } // `for-of` statement (in es5 mode replace with a normal for loop)\n\n\n  forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {\n    const name = this._scope.toName(nameOrPrefix);\n\n    if (this.opts.es5) {\n      const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n      return this.forRange(\"_i\", 0, code_1._`${arr}.length`, i => {\n        this.var(name, code_1._`${arr}[${i}]`);\n        forBody(name);\n      });\n    }\n\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n  } // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n\n\n  forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, code_1._`Object.keys(${obj})`, forBody);\n    }\n\n    const name = this._scope.toName(nameOrPrefix);\n\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n  } // end `for` loop\n\n\n  endFor() {\n    return this._endBlockNode(For);\n  } // `label` statement\n\n\n  label(label) {\n    return this._leafNode(new Label(label));\n  } // `break` statement\n\n\n  break(label) {\n    return this._leafNode(new Break(label));\n  } // `return` statement\n\n\n  return(value) {\n    const node = new Return();\n\n    this._blockNode(node);\n\n    this.code(value);\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node');\n    return this._endBlockNode(Return);\n  } // `try` statement\n\n\n  try(tryBody, catchCode, finallyCode) {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n    const node = new Try();\n\n    this._blockNode(node);\n\n    this.code(tryBody);\n\n    if (catchCode) {\n      const error = this.name(\"e\");\n      this._currNode = node.catch = new Catch(error);\n      catchCode(error);\n    }\n\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally();\n      this.code(finallyCode);\n    }\n\n    return this._endBlockNode(Catch, Finally);\n  } // `throw` statement\n\n\n  throw(error) {\n    return this._leafNode(new Throw(error));\n  } // start self-balancing block\n\n\n  block(body, nodeCount) {\n    this._blockStarts.push(this._nodes.length);\n\n    if (body) this.code(body).endBlock(nodeCount);\n    return this;\n  } // end the current self-balancing block\n\n\n  endBlock(nodeCount) {\n    const len = this._blockStarts.pop();\n\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\");\n    const toClose = this._nodes.length - len;\n\n    if (toClose < 0 || nodeCount !== undefined && toClose !== nodeCount) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n    }\n\n    this._nodes.length = len;\n    return this;\n  } // `function` heading (or definition if funcBody is passed)\n\n\n  func(name, args = code_1.nil, async, funcBody) {\n    this._blockNode(new Func(name, args, async));\n\n    if (funcBody) this.code(funcBody).endFunc();\n    return this;\n  } // end function definition\n\n\n  endFunc() {\n    return this._endBlockNode(Func);\n  }\n\n  optimize(n = 1) {\n    while (n-- > 0) {\n      this._root.optimizeNodes();\n\n      this._root.optimizeNames(this._root.names, this._constants);\n    }\n  }\n\n  _leafNode(node) {\n    this._currNode.nodes.push(node);\n\n    return this;\n  }\n\n  _blockNode(node) {\n    this._currNode.nodes.push(node);\n\n    this._nodes.push(node);\n  }\n\n  _endBlockNode(N1, N2) {\n    const n = this._currNode;\n\n    if (n instanceof N1 || N2 && n instanceof N2) {\n      this._nodes.pop();\n\n      return this;\n    }\n\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n  }\n\n  _elseNode(node) {\n    const n = this._currNode;\n\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"');\n    }\n\n    this._currNode = n.else = node;\n    return this;\n  }\n\n  get _root() {\n    return this._nodes[0];\n  }\n\n  get _currNode() {\n    const ns = this._nodes;\n    return ns[ns.length - 1];\n  }\n\n  set _currNode(node) {\n    const ns = this._nodes;\n    ns[ns.length - 1] = node;\n  }\n\n}\n\nexports.CodeGen = CodeGen;\n\nfunction addNames(names, from) {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0);\n\n  return names;\n}\n\nfunction addExprNames(names, from) {\n  return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\n\nfunction optimizeExpr(expr, names, constants) {\n  if (expr instanceof code_1.Name) return replaceName(expr);\n  if (!canOptimize(expr)) return expr;\n  return new code_1._Code(expr._items.reduce((items, c) => {\n    if (c instanceof code_1.Name) c = replaceName(c);\n    if (c instanceof code_1._Code) items.push(...c._items);else items.push(c);\n    return items;\n  }, []));\n\n  function replaceName(n) {\n    const c = constants[n.str];\n    if (c === undefined || names[n.str] !== 1) return n;\n    delete names[n.str];\n    return c;\n  }\n\n  function canOptimize(e) {\n    return e instanceof code_1._Code && e._items.some(c => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined);\n  }\n}\n\nfunction subtractNames(names, from) {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0);\n}\n\nfunction not(x) {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : code_1._`!${par(x)}`;\n}\n\nexports.not = not;\nconst andCode = mappend(exports.operators.AND); // boolean AND (&&) expression with the passed arguments\n\nfunction and(...args) {\n  return args.reduce(andCode);\n}\n\nexports.and = and;\nconst orCode = mappend(exports.operators.OR); // boolean OR (||) expression with the passed arguments\n\nfunction or(...args) {\n  return args.reduce(orCode);\n}\n\nexports.or = or;\n\nfunction mappend(op) {\n  return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : code_1._`${par(x)} ${op} ${par(y)}`;\n}\n\nfunction par(x) {\n  return x instanceof code_1.Name ? x : code_1._`(${x})`;\n}","map":null,"metadata":{},"sourceType":"script"}